<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="The regex used to slugify our inputs"><meta name="keywords" content="rust, rustlang, rust-lang, REPLACEABLE"><title>REPLACEABLE in rat_rs::utils - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceSerif4-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../FiraSans-Regular.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../FiraSans-Medium.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceCodePro-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceSerif4-Bold.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceCodePro-Semibold.ttf.woff2"><link rel="stylesheet" type="text/css" href="../../normalize.css"><link rel="stylesheet" type="text/css" href="../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../ayu.css" disabled><link rel="stylesheet" type="text/css" href="../../dark.css" disabled><link rel="stylesheet" type="text/css" href="../../light.css" id="themeStyle"><script id="default-settings" ></script><script src="../../storage.js"></script><script src="../../crates.js"></script><script defer src="../../main.js"></script>
    <noscript><link rel="stylesheet" href="../../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../../favicon.svg"></head><body class="rustdoc struct"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="sidebar-logo" href="../../rat_rs/index.html"><div class="logo-container"><img class="rust-logo" src="../../rust-logo.svg" alt="logo"></div>
        </a><h2 class="location"></h2>
    </nav>
    <nav class="sidebar"><a class="sidebar-logo" href="../../rat_rs/index.html"><div class="logo-container"><img class="rust-logo" src="../../rust-logo.svg" alt="logo"></div>
        </a><h2 class="location"><a href="#">REPLACEABLE</a></h2><div class="sidebar-elems"><section><div class="block"><h3 class="sidebar-title"><a href="#fields">Fields</a></h3><ul><li><a href="#structfield.__private_field">__private_field</a></li></ul></div><div class="block"><h3 class="sidebar-title"><a href="#deref-methods-Regex">Methods from Deref&lt;Target=Regex&gt;</a></h3><ul><li><a href="#method.as_str">as_str</a></li><li><a href="#method.capture_locations">capture_locations</a></li><li><a href="#method.capture_names">capture_names</a></li><li><a href="#method.captures">captures</a></li><li><a href="#method.captures_iter">captures_iter</a></li><li><a href="#method.captures_len">captures_len</a></li><li><a href="#method.captures_read">captures_read</a></li><li><a href="#method.captures_read_at">captures_read_at</a></li><li><a href="#method.find">find</a></li><li><a href="#method.find_at">find_at</a></li><li><a href="#method.find_iter">find_iter</a></li><li><a href="#method.is_match">is_match</a></li><li><a href="#method.is_match_at">is_match_at</a></li><li><a href="#method.replace">replace</a></li><li><a href="#method.replace_all">replace_all</a></li><li><a href="#method.replacen">replacen</a></li><li><a href="#method.shortest_match">shortest_match</a></li><li><a href="#method.shortest_match_at">shortest_match_at</a></li><li><a href="#method.split">split</a></li><li><a href="#method.splitn">splitn</a></li></ul></div><div class="block"><h3 class="sidebar-title"><a href="#trait-implementations">Trait Implementations</a></h3><ul><li><a href="#impl-Deref">Deref</a></li><li><a href="#impl-LazyStatic">LazyStatic</a></li></ul></div><div class="block"><h3 class="sidebar-title"><a href="#synthetic-implementations">Auto Trait Implementations</a></h3><ul><li><a href="#impl-RefUnwindSafe">RefUnwindSafe</a></li><li><a href="#impl-Send">Send</a></li><li><a href="#impl-Sync">Sync</a></li><li><a href="#impl-Unpin">Unpin</a></li><li><a href="#impl-UnwindSafe">UnwindSafe</a></li></ul></div><div class="block"><h3 class="sidebar-title"><a href="#blanket-implementations">Blanket Implementations</a></h3><ul><li><a href="#impl-Any">Any</a></li><li><a href="#impl-Borrow%3CT%3E">Borrow&lt;T&gt;</a></li><li><a href="#impl-BorrowMut%3CT%3E">BorrowMut&lt;T&gt;</a></li><li><a href="#impl-From%3CT%3E">From&lt;T&gt;</a></li><li><a href="#impl-Instrument">Instrument</a></li><li><a href="#impl-Into%3CU%3E">Into&lt;U&gt;</a></li><li><a href="#impl-TryFrom%3CU%3E">TryFrom&lt;U&gt;</a></li><li><a href="#impl-TryInto%3CU%3E">TryInto&lt;U&gt;</a></li><li><a href="#impl-WithSubscriber">WithSubscriber</a></li></ul></div></section><h2 class="location"><a href="index.html">In rat_rs::utils</a></h2><div id="sidebar-vars" data-name="REPLACEABLE" data-ty="struct" data-relpath=""></div><script defer src="sidebar-items.js"></script></div></nav><main><div class="width-limiter"><div class="sub-container"><a class="sub-logo-container" href="../../rat_rs/index.html"><img class="rust-logo" src="../../rust-logo.svg" alt="logo"></a><nav class="sub"><div class="theme-picker hidden"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu" title="themes"><img width="22" height="22" alt="Pick another theme!" src="../../brush.svg"></button><div id="theme-choices" role="menu"></div></div><form class="search-form"><div class="search-container"><span></span><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><button type="button" id="help-button" title="help">?</button><a id="settings-menu" href="../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../wheel.svg"></a></div></form></nav></div><section id="main-content" class="content"><div class="main-heading">
    <h1 class="fqn"><span class="in-band">Struct <a href="../index.html">rat_rs</a>::<wbr><a href="index.html">utils</a>::<wbr><a class="struct" href="#">REPLACEABLE</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../../clipboard.svg" width="19" height="18" alt="Copy item path"></button></span></h1><span class="out-of-band"><a class="srclink" href="../../src/rat_rs/utils.rs.html#4-7">source</a> · <a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span></div><div class="docblock item-decl"><pre class="rust struct"><code>struct REPLACEABLE {
    __private_field: <a class="primitive" href="https://doc.rust-lang.org/1.62.0/std/primitive.unit.html">()</a>,
}</code></pre></div><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>The regex used to slugify our inputs</p>
</div></details><h2 id="fields" class="fields small-section-header">Fields<a href="#fields" class="anchor"></a></h2><span id="structfield.__private_field" class="structfield small-section-header"><a href="#structfield.__private_field" class="anchor field"></a><code>__private_field: <a class="primitive" href="https://doc.rust-lang.org/1.62.0/std/primitive.unit.html">()</a></code></span><h2 id="deref-methods-Regex" class="small-section-header"><span>Methods from <a class="trait" href="https://doc.rust-lang.org/1.62.0/core/ops/deref/trait.Deref.html" title="trait core::ops::deref::Deref">Deref</a>&lt;Target = Regex&gt;</span><a href="#deref-methods-Regex" class="anchor"></a></h2><div id="deref-methods-Regex-1"><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.is_match" class="method has-srclink"><a href="#method.is_match" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.is_match" class="fnname">is_match</a>(&amp;self, text: &amp;<a class="primitive" href="https://doc.rust-lang.org/1.62.0/std/primitive.str.html">str</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.62.0/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Returns true if and only if there is a match for the regex in the
string given.</p>
<p>It is recommended to use this method if all you need to do is test
a match, since the underlying matching engine may be able to do less
work.</p>
<h5 id="example"><a href="#example">Example</a></h5>
<p>Test if some text contains at least one word with exactly 13
Unicode word characters:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">text</span> <span class="op">=</span> <span class="string">&quot;I categorically deny having triskaidekaphobia.&quot;</span>;
<span class="macro">assert!</span>(<span class="ident">Regex::new</span>(<span class="string">r&quot;\b\w{13}\b&quot;</span>).<span class="ident">unwrap</span>().<span class="ident">is_match</span>(<span class="ident">text</span>));</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.find" class="method has-srclink"><a href="#method.find" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.find" class="fnname">find</a>(&amp;self, text: &amp;'t <a class="primitive" href="https://doc.rust-lang.org/1.62.0/std/primitive.str.html">str</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.62.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;Match&lt;'t&gt;&gt;</h4></section></summary><div class="docblock"><p>Returns the start and end byte range of the leftmost-first match in
<code>text</code>. If no match exists, then <code>None</code> is returned.</p>
<p>Note that this should only be used if you want to discover the position
of the match. Testing the existence of a match is faster if you use
<code>is_match</code>.</p>
<h5 id="example-1"><a href="#example-1">Example</a></h5>
<p>Find the start and end location of the first word with exactly 13
Unicode word characters:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">text</span> <span class="op">=</span> <span class="string">&quot;I categorically deny having triskaidekaphobia.&quot;</span>;
<span class="kw">let</span> <span class="ident">mat</span> <span class="op">=</span> <span class="ident">Regex::new</span>(<span class="string">r&quot;\b\w{13}\b&quot;</span>).<span class="ident">unwrap</span>().<span class="ident">find</span>(<span class="ident">text</span>).<span class="ident">unwrap</span>();
<span class="macro">assert_eq!</span>(<span class="ident">mat</span>.<span class="ident">start</span>(), <span class="number">2</span>);
<span class="macro">assert_eq!</span>(<span class="ident">mat</span>.<span class="ident">end</span>(), <span class="number">15</span>);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.find_iter" class="method has-srclink"><a href="#method.find_iter" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.find_iter" class="fnname">find_iter</a>(&amp;'r self, text: &amp;'t <a class="primitive" href="https://doc.rust-lang.org/1.62.0/std/primitive.str.html">str</a>) -&gt; Matches&lt;'r, 't&gt;</h4></section></summary><div class="docblock"><p>Returns an iterator for each successive non-overlapping match in
<code>text</code>, returning the start and end byte indices with respect to
<code>text</code>.</p>
<h5 id="example-2"><a href="#example-2">Example</a></h5>
<p>Find the start and end location of every word with exactly 13 Unicode
word characters:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">text</span> <span class="op">=</span> <span class="string">&quot;Retroactively relinquishing remunerations is reprehensible.&quot;</span>;
<span class="kw">for</span> <span class="ident">mat</span> <span class="kw">in</span> <span class="ident">Regex::new</span>(<span class="string">r&quot;\b\w{13}\b&quot;</span>).<span class="ident">unwrap</span>().<span class="ident">find_iter</span>(<span class="ident">text</span>) {
    <span class="macro">println!</span>(<span class="string">&quot;{:?}&quot;</span>, <span class="ident">mat</span>);
}</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.captures" class="method has-srclink"><a href="#method.captures" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.captures" class="fnname">captures</a>(&amp;self, text: &amp;'t <a class="primitive" href="https://doc.rust-lang.org/1.62.0/std/primitive.str.html">str</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.62.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;Captures&lt;'t&gt;&gt;</h4></section></summary><div class="docblock"><p>Returns the capture groups corresponding to the leftmost-first
match in <code>text</code>. Capture group <code>0</code> always corresponds to the entire
match. If no match is found, then <code>None</code> is returned.</p>
<p>You should only use <code>captures</code> if you need access to the location of
capturing group matches. Otherwise, <code>find</code> is faster for discovering
the location of the overall match.</p>
<h5 id="examples"><a href="#examples">Examples</a></h5>
<p>Say you have some text with movie names and their release years,
like “‘Citizen Kane’ (1941)”. It’d be nice if we could search for text
looking like that, while also extracting the movie name and its release
year separately.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">re</span> <span class="op">=</span> <span class="ident">Regex::new</span>(<span class="string">r&quot;&#39;([^&#39;]+)&#39;\s+\((\d{4})\)&quot;</span>).<span class="ident">unwrap</span>();
<span class="kw">let</span> <span class="ident">text</span> <span class="op">=</span> <span class="string">&quot;Not my favorite movie: &#39;Citizen Kane&#39; (1941).&quot;</span>;
<span class="kw">let</span> <span class="ident">caps</span> <span class="op">=</span> <span class="ident">re</span>.<span class="ident">captures</span>(<span class="ident">text</span>).<span class="ident">unwrap</span>();
<span class="macro">assert_eq!</span>(<span class="ident">caps</span>.<span class="ident">get</span>(<span class="number">1</span>).<span class="ident">unwrap</span>().<span class="ident">as_str</span>(), <span class="string">&quot;Citizen Kane&quot;</span>);
<span class="macro">assert_eq!</span>(<span class="ident">caps</span>.<span class="ident">get</span>(<span class="number">2</span>).<span class="ident">unwrap</span>().<span class="ident">as_str</span>(), <span class="string">&quot;1941&quot;</span>);
<span class="macro">assert_eq!</span>(<span class="ident">caps</span>.<span class="ident">get</span>(<span class="number">0</span>).<span class="ident">unwrap</span>().<span class="ident">as_str</span>(), <span class="string">&quot;&#39;Citizen Kane&#39; (1941)&quot;</span>);
<span class="comment">// You can also access the groups by index using the Index notation.</span>
<span class="comment">// Note that this will panic on an invalid index.</span>
<span class="macro">assert_eq!</span>(<span class="kw-2">&amp;</span><span class="ident">caps</span>[<span class="number">1</span>], <span class="string">&quot;Citizen Kane&quot;</span>);
<span class="macro">assert_eq!</span>(<span class="kw-2">&amp;</span><span class="ident">caps</span>[<span class="number">2</span>], <span class="string">&quot;1941&quot;</span>);
<span class="macro">assert_eq!</span>(<span class="kw-2">&amp;</span><span class="ident">caps</span>[<span class="number">0</span>], <span class="string">&quot;&#39;Citizen Kane&#39; (1941)&quot;</span>);</code></pre></div>
<p>Note that the full match is at capture group <code>0</code>. Each subsequent
capture group is indexed by the order of its opening <code>(</code>.</p>
<p>We can make this example a bit clearer by using <em>named</em> capture groups:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">re</span> <span class="op">=</span> <span class="ident">Regex::new</span>(<span class="string">r&quot;&#39;(?P&lt;title&gt;[^&#39;]+)&#39;\s+\((?P&lt;year&gt;\d{4})\)&quot;</span>)
               .<span class="ident">unwrap</span>();
<span class="kw">let</span> <span class="ident">text</span> <span class="op">=</span> <span class="string">&quot;Not my favorite movie: &#39;Citizen Kane&#39; (1941).&quot;</span>;
<span class="kw">let</span> <span class="ident">caps</span> <span class="op">=</span> <span class="ident">re</span>.<span class="ident">captures</span>(<span class="ident">text</span>).<span class="ident">unwrap</span>();
<span class="macro">assert_eq!</span>(<span class="ident">caps</span>.<span class="ident">name</span>(<span class="string">&quot;title&quot;</span>).<span class="ident">unwrap</span>().<span class="ident">as_str</span>(), <span class="string">&quot;Citizen Kane&quot;</span>);
<span class="macro">assert_eq!</span>(<span class="ident">caps</span>.<span class="ident">name</span>(<span class="string">&quot;year&quot;</span>).<span class="ident">unwrap</span>().<span class="ident">as_str</span>(), <span class="string">&quot;1941&quot;</span>);
<span class="macro">assert_eq!</span>(<span class="ident">caps</span>.<span class="ident">get</span>(<span class="number">0</span>).<span class="ident">unwrap</span>().<span class="ident">as_str</span>(), <span class="string">&quot;&#39;Citizen Kane&#39; (1941)&quot;</span>);
<span class="comment">// You can also access the groups by name using the Index notation.</span>
<span class="comment">// Note that this will panic on an invalid group name.</span>
<span class="macro">assert_eq!</span>(<span class="kw-2">&amp;</span><span class="ident">caps</span>[<span class="string">&quot;title&quot;</span>], <span class="string">&quot;Citizen Kane&quot;</span>);
<span class="macro">assert_eq!</span>(<span class="kw-2">&amp;</span><span class="ident">caps</span>[<span class="string">&quot;year&quot;</span>], <span class="string">&quot;1941&quot;</span>);
<span class="macro">assert_eq!</span>(<span class="kw-2">&amp;</span><span class="ident">caps</span>[<span class="number">0</span>], <span class="string">&quot;&#39;Citizen Kane&#39; (1941)&quot;</span>);
</code></pre></div>
<p>Here we name the capture groups, which we can access with the <code>name</code>
method or the <code>Index</code> notation with a <code>&amp;str</code>. Note that the named
capture groups are still accessible with <code>get</code> or the <code>Index</code> notation
with a <code>usize</code>.</p>
<p>The <code>0</code>th capture group is always unnamed, so it must always be
accessed with <code>get(0)</code> or <code>[0]</code>.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.captures_iter" class="method has-srclink"><a href="#method.captures_iter" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.captures_iter" class="fnname">captures_iter</a>(&amp;'r self, text: &amp;'t <a class="primitive" href="https://doc.rust-lang.org/1.62.0/std/primitive.str.html">str</a>) -&gt; CaptureMatches&lt;'r, 't&gt;</h4></section></summary><div class="docblock"><p>Returns an iterator over all the non-overlapping capture groups matched
in <code>text</code>. This is operationally the same as <code>find_iter</code>, except it
yields information about capturing group matches.</p>
<h5 id="example-3"><a href="#example-3">Example</a></h5>
<p>We can use this to find all movie titles and their release years in
some text, where the movie is formatted like “‘Title’ (xxxx)”:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">re</span> <span class="op">=</span> <span class="ident">Regex::new</span>(<span class="string">r&quot;&#39;(?P&lt;title&gt;[^&#39;]+)&#39;\s+\((?P&lt;year&gt;\d{4})\)&quot;</span>)
               .<span class="ident">unwrap</span>();
<span class="kw">let</span> <span class="ident">text</span> <span class="op">=</span> <span class="string">&quot;&#39;Citizen Kane&#39; (1941), &#39;The Wizard of Oz&#39; (1939), &#39;M&#39; (1931).&quot;</span>;
<span class="kw">for</span> <span class="ident">caps</span> <span class="kw">in</span> <span class="ident">re</span>.<span class="ident">captures_iter</span>(<span class="ident">text</span>) {
    <span class="macro">println!</span>(<span class="string">&quot;Movie: {:?}, Released: {:?}&quot;</span>,
             <span class="kw-2">&amp;</span><span class="ident">caps</span>[<span class="string">&quot;title&quot;</span>], <span class="kw-2">&amp;</span><span class="ident">caps</span>[<span class="string">&quot;year&quot;</span>]);
}
<span class="comment">// Output:</span>
<span class="comment">// Movie: Citizen Kane, Released: 1941</span>
<span class="comment">// Movie: The Wizard of Oz, Released: 1939</span>
<span class="comment">// Movie: M, Released: 1931</span></code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.split" class="method has-srclink"><a href="#method.split" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.split" class="fnname">split</a>(&amp;'r self, text: &amp;'t <a class="primitive" href="https://doc.rust-lang.org/1.62.0/std/primitive.str.html">str</a>) -&gt; Split&lt;'r, 't&gt;</h4></section></summary><div class="docblock"><p>Returns an iterator of substrings of <code>text</code> delimited by a match of the
regular expression. Namely, each element of the iterator corresponds to
text that <em>isn’t</em> matched by the regular expression.</p>
<p>This method will <em>not</em> copy the text given.</p>
<h5 id="example-4"><a href="#example-4">Example</a></h5>
<p>To split a string delimited by arbitrary amounts of spaces or tabs:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">re</span> <span class="op">=</span> <span class="ident">Regex::new</span>(<span class="string">r&quot;[ \t]+&quot;</span>).<span class="ident">unwrap</span>();
<span class="kw">let</span> <span class="ident">fields</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">re</span>.<span class="ident">split</span>(<span class="string">&quot;a b \t  c\td    e&quot;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq!</span>(<span class="ident">fields</span>, <span class="macro">vec!</span>[<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>, <span class="string">&quot;e&quot;</span>]);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.splitn" class="method has-srclink"><a href="#method.splitn" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.splitn" class="fnname">splitn</a>(&amp;'r self, text: &amp;'t <a class="primitive" href="https://doc.rust-lang.org/1.62.0/std/primitive.str.html">str</a>, limit: <a class="primitive" href="https://doc.rust-lang.org/1.62.0/std/primitive.usize.html">usize</a>) -&gt; SplitN&lt;'r, 't&gt;</h4></section></summary><div class="docblock"><p>Returns an iterator of at most <code>limit</code> substrings of <code>text</code> delimited
by a match of the regular expression. (A <code>limit</code> of <code>0</code> will return no
substrings.) Namely, each element of the iterator corresponds to text
that <em>isn’t</em> matched by the regular expression. The remainder of the
string that is not split will be the last element in the iterator.</p>
<p>This method will <em>not</em> copy the text given.</p>
<h5 id="example-5"><a href="#example-5">Example</a></h5>
<p>Get the first two words in some text:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">re</span> <span class="op">=</span> <span class="ident">Regex::new</span>(<span class="string">r&quot;\W+&quot;</span>).<span class="ident">unwrap</span>();
<span class="kw">let</span> <span class="ident">fields</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">re</span>.<span class="ident">splitn</span>(<span class="string">&quot;Hey! How are you?&quot;</span>, <span class="number">3</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq!</span>(<span class="ident">fields</span>, <span class="macro">vec!</span>(<span class="string">&quot;Hey&quot;</span>, <span class="string">&quot;How&quot;</span>, <span class="string">&quot;are you?&quot;</span>));</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.replace" class="method has-srclink"><a href="#method.replace" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.replace" class="fnname">replace</a>&lt;R&gt;(&amp;self, text: &amp;'t <a class="primitive" href="https://doc.rust-lang.org/1.62.0/std/primitive.str.html">str</a>, rep: R) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.62.0/alloc/borrow/enum.Cow.html" title="enum alloc::borrow::Cow">Cow</a>&lt;'t, <a class="primitive" href="https://doc.rust-lang.org/1.62.0/std/primitive.str.html">str</a>&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;R: Replacer,&nbsp;</span></h4></section></summary><div class="docblock"><p>Replaces the leftmost-first match with the replacement provided.
The replacement can be a regular string (where <code>$N</code> and <code>$name</code> are
expanded to match capture groups) or a function that takes the matches’
<code>Captures</code> and returns the replaced string.</p>
<p>If no match is found, then a copy of the string is returned unchanged.</p>
<h5 id="replacement-string-syntax"><a href="#replacement-string-syntax">Replacement string syntax</a></h5>
<p>All instances of <code>$name</code> in the replacement text is replaced with the
corresponding capture group <code>name</code>.</p>
<p><code>name</code> may be an integer corresponding to the index of the
capture group (counted by order of opening parenthesis where <code>0</code> is the
entire match) or it can be a name (consisting of letters, digits or
underscores) corresponding to a named capture group.</p>
<p>If <code>name</code> isn’t a valid capture group (whether the name doesn’t exist
or isn’t a valid index), then it is replaced with the empty string.</p>
<p>The longest possible name is used. e.g., <code>$1a</code> looks up the capture
group named <code>1a</code> and not the capture group at index <code>1</code>. To exert more
precise control over the name, use braces, e.g., <code>${1}a</code>.</p>
<p>To write a literal <code>$</code> use <code>$$</code>.</p>
<h5 id="examples-1"><a href="#examples-1">Examples</a></h5>
<p>Note that this function is polymorphic with respect to the replacement.
In typical usage, this can just be a normal string:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">re</span> <span class="op">=</span> <span class="ident">Regex::new</span>(<span class="string">&quot;[^01]+&quot;</span>).<span class="ident">unwrap</span>();
<span class="macro">assert_eq!</span>(<span class="ident">re</span>.<span class="ident">replace</span>(<span class="string">&quot;1078910&quot;</span>, <span class="string">&quot;&quot;</span>), <span class="string">&quot;1010&quot;</span>);</code></pre></div>
<p>But anything satisfying the <code>Replacer</code> trait will work. For example,
a closure of type <code>|&amp;Captures| -&gt; String</code> provides direct access to the
captures corresponding to a match. This allows one to access
capturing group matches easily:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">re</span> <span class="op">=</span> <span class="ident">Regex::new</span>(<span class="string">r&quot;([^,\s]+),\s+(\S+)&quot;</span>).<span class="ident">unwrap</span>();
<span class="kw">let</span> <span class="ident">result</span> <span class="op">=</span> <span class="ident">re</span>.<span class="ident">replace</span>(<span class="string">&quot;Springsteen, Bruce&quot;</span>, <span class="op">|</span><span class="ident">caps</span>: <span class="kw-2">&amp;</span><span class="ident">Captures</span><span class="op">|</span> {
    <span class="macro">format!</span>(<span class="string">&quot;{} {}&quot;</span>, <span class="kw-2">&amp;</span><span class="ident">caps</span>[<span class="number">2</span>], <span class="kw-2">&amp;</span><span class="ident">caps</span>[<span class="number">1</span>])
});
<span class="macro">assert_eq!</span>(<span class="ident">result</span>, <span class="string">&quot;Bruce Springsteen&quot;</span>);</code></pre></div>
<p>But this is a bit cumbersome to use all the time. Instead, a simple
syntax is supported that expands <code>$name</code> into the corresponding capture
group. Here’s the last example, but using this expansion technique
with named capture groups:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">re</span> <span class="op">=</span> <span class="ident">Regex::new</span>(<span class="string">r&quot;(?P&lt;last&gt;[^,\s]+),\s+(?P&lt;first&gt;\S+)&quot;</span>).<span class="ident">unwrap</span>();
<span class="kw">let</span> <span class="ident">result</span> <span class="op">=</span> <span class="ident">re</span>.<span class="ident">replace</span>(<span class="string">&quot;Springsteen, Bruce&quot;</span>, <span class="string">&quot;$first $last&quot;</span>);
<span class="macro">assert_eq!</span>(<span class="ident">result</span>, <span class="string">&quot;Bruce Springsteen&quot;</span>);</code></pre></div>
<p>Note that using <code>$2</code> instead of <code>$first</code> or <code>$1</code> instead of <code>$last</code>
would produce the same result. To write a literal <code>$</code> use <code>$$</code>.</p>
<p>Sometimes the replacement string requires use of curly braces to
delineate a capture group replacement and surrounding literal text.
For example, if we wanted to join two words together with an
underscore:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">re</span> <span class="op">=</span> <span class="ident">Regex::new</span>(<span class="string">r&quot;(?P&lt;first&gt;\w+)\s+(?P&lt;second&gt;\w+)&quot;</span>).<span class="ident">unwrap</span>();
<span class="kw">let</span> <span class="ident">result</span> <span class="op">=</span> <span class="ident">re</span>.<span class="ident">replace</span>(<span class="string">&quot;deep fried&quot;</span>, <span class="string">&quot;${first}_$second&quot;</span>);
<span class="macro">assert_eq!</span>(<span class="ident">result</span>, <span class="string">&quot;deep_fried&quot;</span>);</code></pre></div>
<p>Without the curly braces, the capture group name <code>first_</code> would be
used, and since it doesn’t exist, it would be replaced with the empty
string.</p>
<p>Finally, sometimes you just want to replace a literal string with no
regard for capturing group expansion. This can be done by wrapping a
byte string with <code>NoExpand</code>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">regex::NoExpand</span>;

<span class="kw">let</span> <span class="ident">re</span> <span class="op">=</span> <span class="ident">Regex::new</span>(<span class="string">r&quot;(?P&lt;last&gt;[^,\s]+),\s+(\S+)&quot;</span>).<span class="ident">unwrap</span>();
<span class="kw">let</span> <span class="ident">result</span> <span class="op">=</span> <span class="ident">re</span>.<span class="ident">replace</span>(<span class="string">&quot;Springsteen, Bruce&quot;</span>, <span class="ident">NoExpand</span>(<span class="string">&quot;$2 $last&quot;</span>));
<span class="macro">assert_eq!</span>(<span class="ident">result</span>, <span class="string">&quot;$2 $last&quot;</span>);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.replace_all" class="method has-srclink"><a href="#method.replace_all" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.replace_all" class="fnname">replace_all</a>&lt;R&gt;(&amp;self, text: &amp;'t <a class="primitive" href="https://doc.rust-lang.org/1.62.0/std/primitive.str.html">str</a>, rep: R) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.62.0/alloc/borrow/enum.Cow.html" title="enum alloc::borrow::Cow">Cow</a>&lt;'t, <a class="primitive" href="https://doc.rust-lang.org/1.62.0/std/primitive.str.html">str</a>&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;R: Replacer,&nbsp;</span></h4></section></summary><div class="docblock"><p>Replaces all non-overlapping matches in <code>text</code> with the replacement
provided. This is the same as calling <code>replacen</code> with <code>limit</code> set to
<code>0</code>.</p>
<p>See the documentation for <code>replace</code> for details on how to access
capturing group matches in the replacement string.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.replacen" class="method has-srclink"><a href="#method.replacen" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.replacen" class="fnname">replacen</a>&lt;R&gt;(&amp;self, text: &amp;'t <a class="primitive" href="https://doc.rust-lang.org/1.62.0/std/primitive.str.html">str</a>, limit: <a class="primitive" href="https://doc.rust-lang.org/1.62.0/std/primitive.usize.html">usize</a>, rep: R) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.62.0/alloc/borrow/enum.Cow.html" title="enum alloc::borrow::Cow">Cow</a>&lt;'t, <a class="primitive" href="https://doc.rust-lang.org/1.62.0/std/primitive.str.html">str</a>&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;R: Replacer,&nbsp;</span></h4></section></summary><div class="docblock"><p>Replaces at most <code>limit</code> non-overlapping matches in <code>text</code> with the
replacement provided. If <code>limit</code> is 0, then all non-overlapping matches
are replaced.</p>
<p>See the documentation for <code>replace</code> for details on how to access
capturing group matches in the replacement string.</p>
</div></details></div><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.shortest_match" class="method has-srclink"><a href="#method.shortest_match" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.shortest_match" class="fnname">shortest_match</a>(&amp;self, text: &amp;<a class="primitive" href="https://doc.rust-lang.org/1.62.0/std/primitive.str.html">str</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.62.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.62.0/std/primitive.usize.html">usize</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the end location of a match in the text given.</p>
<p>This method may have the same performance characteristics as
<code>is_match</code>, except it provides an end location for a match. In
particular, the location returned <em>may be shorter</em> than the proper end
of the leftmost-first match.</p>
<h5 id="example-6"><a href="#example-6">Example</a></h5>
<p>Typically, <code>a+</code> would match the entire first sequence of <code>a</code> in some
text, but <code>shortest_match</code> can give up as soon as it sees the first
<code>a</code>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">text</span> <span class="op">=</span> <span class="string">&quot;aaaaa&quot;</span>;
<span class="kw">let</span> <span class="ident">pos</span> <span class="op">=</span> <span class="ident">Regex::new</span>(<span class="string">r&quot;a+&quot;</span>).<span class="ident">unwrap</span>().<span class="ident">shortest_match</span>(<span class="ident">text</span>);
<span class="macro">assert_eq!</span>(<span class="ident">pos</span>, <span class="prelude-val">Some</span>(<span class="number">1</span>));</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.shortest_match_at" class="method has-srclink"><a href="#method.shortest_match_at" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.shortest_match_at" class="fnname">shortest_match_at</a>(&amp;self, text: &amp;<a class="primitive" href="https://doc.rust-lang.org/1.62.0/std/primitive.str.html">str</a>, start: <a class="primitive" href="https://doc.rust-lang.org/1.62.0/std/primitive.usize.html">usize</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.62.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.62.0/std/primitive.usize.html">usize</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the same as shortest_match, but starts the search at the given
offset.</p>
<p>The significance of the starting point is that it takes the surrounding
context into consideration. For example, the <code>\A</code> anchor can only
match when <code>start == 0</code>.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.is_match_at" class="method has-srclink"><a href="#method.is_match_at" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.is_match_at" class="fnname">is_match_at</a>(&amp;self, text: &amp;<a class="primitive" href="https://doc.rust-lang.org/1.62.0/std/primitive.str.html">str</a>, start: <a class="primitive" href="https://doc.rust-lang.org/1.62.0/std/primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.62.0/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Returns the same as is_match, but starts the search at the given
offset.</p>
<p>The significance of the starting point is that it takes the surrounding
context into consideration. For example, the <code>\A</code> anchor can only
match when <code>start == 0</code>.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.find_at" class="method has-srclink"><a href="#method.find_at" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.find_at" class="fnname">find_at</a>(&amp;self, text: &amp;'t <a class="primitive" href="https://doc.rust-lang.org/1.62.0/std/primitive.str.html">str</a>, start: <a class="primitive" href="https://doc.rust-lang.org/1.62.0/std/primitive.usize.html">usize</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.62.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;Match&lt;'t&gt;&gt;</h4></section></summary><div class="docblock"><p>Returns the same as find, but starts the search at the given
offset.</p>
<p>The significance of the starting point is that it takes the surrounding
context into consideration. For example, the <code>\A</code> anchor can only
match when <code>start == 0</code>.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.captures_read" class="method has-srclink"><a href="#method.captures_read" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.captures_read" class="fnname">captures_read</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;locs: &amp;mut CaptureLocations, <br>&nbsp;&nbsp;&nbsp;&nbsp;text: &amp;'t <a class="primitive" href="https://doc.rust-lang.org/1.62.0/std/primitive.str.html">str</a><br>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.62.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;Match&lt;'t&gt;&gt;</h4></section></summary><div class="docblock"><p>This is like <code>captures</code>, but uses
<a href="struct.CaptureLocations.html"><code>CaptureLocations</code></a>
instead of
<a href="struct.Captures.html"><code>Captures</code></a> in order to amortize allocations.</p>
<p>To create a <code>CaptureLocations</code> value, use the
<code>Regex::capture_locations</code> method.</p>
<p>This returns the overall match if this was successful, which is always
equivalence to the <code>0</code>th capture group.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.captures_read_at" class="method has-srclink"><a href="#method.captures_read_at" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.captures_read_at" class="fnname">captures_read_at</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;locs: &amp;mut CaptureLocations, <br>&nbsp;&nbsp;&nbsp;&nbsp;text: &amp;'t <a class="primitive" href="https://doc.rust-lang.org/1.62.0/std/primitive.str.html">str</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;start: <a class="primitive" href="https://doc.rust-lang.org/1.62.0/std/primitive.usize.html">usize</a><br>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.62.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;Match&lt;'t&gt;&gt;</h4></section></summary><div class="docblock"><p>Returns the same as captures, but starts the search at the given
offset and populates the capture locations given.</p>
<p>The significance of the starting point is that it takes the surrounding
context into consideration. For example, the <code>\A</code> anchor can only
match when <code>start == 0</code>.</p>
</div></details></div><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.as_str" class="method has-srclink"><a href="#method.as_str" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.as_str" class="fnname">as_str</a>(&amp;self) -&gt; &amp;<a class="primitive" href="https://doc.rust-lang.org/1.62.0/std/primitive.str.html">str</a></h4></section></summary><div class="docblock"><p>Returns the original string of this regex.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.capture_names" class="method has-srclink"><a href="#method.capture_names" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.capture_names" class="fnname">capture_names</a>(&amp;self) -&gt; CaptureNames&lt;'_&gt;</h4></section></summary><div class="docblock"><p>Returns an iterator over the capture names.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.captures_len" class="method has-srclink"><a href="#method.captures_len" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.captures_len" class="fnname">captures_len</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.62.0/std/primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Returns the number of captures.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.capture_locations" class="method has-srclink"><a href="#method.capture_locations" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.capture_locations" class="fnname">capture_locations</a>(&amp;self) -&gt; CaptureLocations</h4></section></summary><div class="docblock"><p>Returns an empty set of capture locations that can be reused in
multiple calls to <code>captures_read</code> or <code>captures_read_at</code>.</p>
</div></details></div></div><h2 id="trait-implementations" class="small-section-header">Trait Implementations<a href="#trait-implementations" class="anchor"></a></h2><div id="trait-implementations-list"><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-Deref" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/rat_rs/utils.rs.html#4-7">source</a></span><a href="#impl-Deref" class="anchor"></a><h3 class="code-header in-band">impl <a class="trait" href="https://doc.rust-lang.org/1.62.0/core/ops/deref/trait.Deref.html" title="trait core::ops::deref::Deref">Deref</a> for <a class="struct" href="struct.REPLACEABLE.html" title="struct rat_rs::utils::REPLACEABLE">REPLACEABLE</a></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle" open><summary><section id="associatedtype.Target" class="associatedtype trait-impl has-srclink"><a href="#associatedtype.Target" class="anchor"></a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.62.0/core/ops/deref/trait.Deref.html#associatedtype.Target" class="associatedtype">Target</a> = Regex</h4></section></summary><div class='docblock'><p>The resulting type after dereferencing.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.deref" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/rat_rs/utils.rs.html#4-7">source</a></span><a href="#method.deref" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.62.0/core/ops/deref/trait.Deref.html#tymethod.deref" class="fnname">deref</a>(&amp;self) -&gt; &amp;Regex</h4></section></summary><div class='docblock'><p>Dereferences the value.</p>
</div></details></div></details><section id="impl-LazyStatic" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/rat_rs/utils.rs.html#4-7">source</a></span><a href="#impl-LazyStatic" class="anchor"></a><h3 class="code-header in-band">impl <a class="trait" href="https://docs.rs/lazy_static/1.4.0/lazy_static/trait.LazyStatic.html" title="trait lazy_static::LazyStatic">LazyStatic</a> for <a class="struct" href="struct.REPLACEABLE.html" title="struct rat_rs::utils::REPLACEABLE">REPLACEABLE</a></h3></section></div><h2 id="synthetic-implementations" class="small-section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor"></a></h2><div id="synthetic-implementations-list"><section id="impl-RefUnwindSafe" class="impl has-srclink"><a href="#impl-RefUnwindSafe" class="anchor"></a><h3 class="code-header in-band">impl <a class="trait" href="https://doc.rust-lang.org/1.62.0/core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a> for <a class="struct" href="struct.REPLACEABLE.html" title="struct rat_rs::utils::REPLACEABLE">REPLACEABLE</a></h3></section><section id="impl-Send" class="impl has-srclink"><a href="#impl-Send" class="anchor"></a><h3 class="code-header in-band">impl <a class="trait" href="https://doc.rust-lang.org/1.62.0/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> for <a class="struct" href="struct.REPLACEABLE.html" title="struct rat_rs::utils::REPLACEABLE">REPLACEABLE</a></h3></section><section id="impl-Sync" class="impl has-srclink"><a href="#impl-Sync" class="anchor"></a><h3 class="code-header in-band">impl <a class="trait" href="https://doc.rust-lang.org/1.62.0/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> for <a class="struct" href="struct.REPLACEABLE.html" title="struct rat_rs::utils::REPLACEABLE">REPLACEABLE</a></h3></section><section id="impl-Unpin" class="impl has-srclink"><a href="#impl-Unpin" class="anchor"></a><h3 class="code-header in-band">impl <a class="trait" href="https://doc.rust-lang.org/1.62.0/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a> for <a class="struct" href="struct.REPLACEABLE.html" title="struct rat_rs::utils::REPLACEABLE">REPLACEABLE</a></h3></section><section id="impl-UnwindSafe" class="impl has-srclink"><a href="#impl-UnwindSafe" class="anchor"></a><h3 class="code-header in-band">impl <a class="trait" href="https://doc.rust-lang.org/1.62.0/core/panic/unwind_safe/trait.UnwindSafe.html" title="trait core::panic::unwind_safe::UnwindSafe">UnwindSafe</a> for <a class="struct" href="struct.REPLACEABLE.html" title="struct rat_rs::utils::REPLACEABLE">REPLACEABLE</a></h3></section></div><h2 id="blanket-implementations" class="small-section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor"></a></h2><div id="blanket-implementations-list"><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-Any" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.62.0/src/core/any.rs.html#132-136">source</a></span><a href="#impl-Any" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.62.0/core/any/trait.Any.html" title="trait core::any::Any">Any</a> for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'static + ?<a class="trait" href="https://doc.rust-lang.org/1.62.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.type_id" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.62.0/src/core/any.rs.html#133">source</a></span><a href="#method.type_id" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.62.0/core/any/trait.Any.html#tymethod.type_id" class="fnname">type_id</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.62.0/core/any/struct.TypeId.html" title="struct core::any::TypeId">TypeId</a></h4></section></summary><div class='docblock'><p>Gets the <code>TypeId</code> of <code>self</code>. <a href="https://doc.rust-lang.org/1.62.0/core/any/trait.Any.html#tymethod.type_id">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-Borrow%3CT%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.62.0/src/core/borrow.rs.html#209-214">source</a></span><a href="#impl-Borrow%3CT%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.62.0/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;T&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="https://doc.rust-lang.org/1.62.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.borrow" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/91522" title="Tracking issue for const_borrow">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/1.62.0/src/core/borrow.rs.html#211">source</a></span><a href="#method.borrow" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.62.0/core/borrow/trait.Borrow.html#tymethod.borrow" class="fnname">borrow</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.62.0/std/primitive.reference.html">&amp;</a>T</h4></section></summary><div class='docblock'><p>Immutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.62.0/core/borrow/trait.Borrow.html#tymethod.borrow">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-BorrowMut%3CT%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.62.0/src/core/borrow.rs.html#218-222">source</a></span><a href="#impl-BorrowMut%3CT%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.62.0/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="https://doc.rust-lang.org/1.62.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.borrow_mut" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/91522" title="Tracking issue for const_borrow">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/1.62.0/src/core/borrow.rs.html#219">source</a></span><a href="#method.borrow_mut" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.62.0/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fnname">borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.62.0/std/primitive.reference.html">&amp;mut </a>T</h4></section></summary><div class='docblock'><p>Mutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.62.0/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-From%3CT%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.62.0/src/core/convert/mod.rs.html#557-562">source</a></span><a href="#impl-From%3CT%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.62.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for T</h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.from" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/88674" title="Tracking issue for const_convert">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/1.62.0/src/core/convert/mod.rs.html#559">source</a></span><a href="#method.from" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.62.0/core/convert/trait.From.html#tymethod.from" class="fnname">from</a>(t: T) -&gt; T</h4></section></summary><div class="docblock"><p>Returns the argument unchanged.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-Instrument" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://docs.rs/tracing/0.1.34/src/tracing/instrument.rs.html#276">source</a></span><a href="#impl-Instrument" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="https://docs.rs/tracing/0.1.34/tracing/instrument/trait.Instrument.html" title="trait tracing::instrument::Instrument">Instrument</a> for T</h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.instrument" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://docs.rs/tracing/0.1.34/src/tracing/instrument.rs.html#82">source</a></span><a href="#method.instrument" class="anchor"></a><h4 class="code-header">fn <a href="https://docs.rs/tracing/0.1.34/tracing/instrument/trait.Instrument.html#method.instrument" class="fnname">instrument</a>(self, span: <a class="struct" href="https://docs.rs/tracing/0.1.34/tracing/span/struct.Span.html" title="struct tracing::span::Span">Span</a>) -&gt; <a class="struct" href="https://docs.rs/tracing/0.1.34/tracing/instrument/struct.Instrumented.html" title="struct tracing::instrument::Instrumented">Instrumented</a>&lt;Self&gt;</h4></section></summary><div class='docblock'><p>Instruments this type with the provided <a href="https://docs.rs/tracing/0.1.34/tracing/span/struct.Span.html" title="Span"><code>Span</code></a>, returning an
<code>Instrumented</code> wrapper. <a href="https://docs.rs/tracing/0.1.34/tracing/instrument/trait.Instrument.html#method.instrument">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.in_current_span" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://docs.rs/tracing/0.1.34/src/tracing/instrument.rs.html#121">source</a></span><a href="#method.in_current_span" class="anchor"></a><h4 class="code-header">fn <a href="https://docs.rs/tracing/0.1.34/tracing/instrument/trait.Instrument.html#method.in_current_span" class="fnname">in_current_span</a>(self) -&gt; <a class="struct" href="https://docs.rs/tracing/0.1.34/tracing/instrument/struct.Instrumented.html" title="struct tracing::instrument::Instrumented">Instrumented</a>&lt;Self&gt;</h4></section></summary><div class='docblock'><p>Instruments this type with the <a href="https://docs.rs/tracing/0.1.34/tracing/span/struct.Span.html#method.current">current</a> <a href="https://docs.rs/tracing/0.1.34/tracing/span/struct.Span.html"><code>Span</code></a>, returning an
<code>Instrumented</code> wrapper. <a href="https://docs.rs/tracing/0.1.34/tracing/instrument/trait.Instrument.html#method.in_current_span">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-Into%3CU%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.62.0/src/core/convert/mod.rs.html#541-552">source</a></span><a href="#impl-Into%3CU%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.62.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="https://doc.rust-lang.org/1.62.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt;,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.into" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/88674" title="Tracking issue for const_convert">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/1.62.0/src/core/convert/mod.rs.html#549">source</a></span><a href="#method.into" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.62.0/core/convert/trait.Into.html#tymethod.into" class="fnname">into</a>(self) -&gt; U</h4></section></summary><div class="docblock"><p>Calls <code>U::from(self)</code>.</p>
<p>That is, this conversion is whatever the implementation of
<code><a href="https://doc.rust-lang.org/1.62.0/core/convert/trait.From.html" title="From">From</a>&lt;T&gt; for U</code> chooses to do.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-TryFrom%3CU%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.62.0/src/core/convert/mod.rs.html#598-607">source</a></span><a href="#impl-TryFrom%3CU%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.62.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="https://doc.rust-lang.org/1.62.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;T&gt;,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle" open><summary><section id="associatedtype.Error-1" class="associatedtype trait-impl has-srclink"><a href="#associatedtype.Error-1" class="anchor"></a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.62.0/core/convert/trait.TryFrom.html#associatedtype.Error" class="associatedtype">Error</a> = <a class="enum" href="https://doc.rust-lang.org/1.62.0/core/convert/enum.Infallible.html" title="enum core::convert::Infallible">Infallible</a></h4></section></summary><div class='docblock'><p>The type returned in the event of a conversion error.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.try_from" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/88674" title="Tracking issue for const_convert">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/1.62.0/src/core/convert/mod.rs.html#604">source</a></span><a href="#method.try_from" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.62.0/core/convert/trait.TryFrom.html#tymethod.try_from" class="fnname">try_from</a>(value: U) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.62.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="https://doc.rust-lang.org/1.62.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.62.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'><p>Performs the conversion.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-TryInto%3CU%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.62.0/src/core/convert/mod.rs.html#583-592">source</a></span><a href="#impl-TryInto%3CU%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.62.0/core/convert/trait.TryInto.html" title="trait core::convert::TryInto">TryInto</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="https://doc.rust-lang.org/1.62.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle" open><summary><section id="associatedtype.Error" class="associatedtype trait-impl has-srclink"><a href="#associatedtype.Error" class="anchor"></a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.62.0/core/convert/trait.TryInto.html#associatedtype.Error" class="associatedtype">Error</a> = &lt;U as <a class="trait" href="https://doc.rust-lang.org/1.62.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.62.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a></h4></section></summary><div class='docblock'><p>The type returned in the event of a conversion error.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.try_into" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/88674" title="Tracking issue for const_convert">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/1.62.0/src/core/convert/mod.rs.html#589">source</a></span><a href="#method.try_into" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.62.0/core/convert/trait.TryInto.html#tymethod.try_into" class="fnname">try_into</a>(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.62.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="https://doc.rust-lang.org/1.62.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.62.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'><p>Performs the conversion.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-WithSubscriber" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://docs.rs/tracing/0.1.34/src/tracing/instrument.rs.html#334">source</a></span><a href="#impl-WithSubscriber" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="https://docs.rs/tracing/0.1.34/tracing/instrument/trait.WithSubscriber.html" title="trait tracing::instrument::WithSubscriber">WithSubscriber</a> for T</h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.with_subscriber" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://docs.rs/tracing/0.1.34/src/tracing/instrument.rs.html#169-171">source</a></span><a href="#method.with_subscriber" class="anchor"></a><h4 class="code-header">fn <a href="https://docs.rs/tracing/0.1.34/tracing/instrument/trait.WithSubscriber.html#method.with_subscriber" class="fnname">with_subscriber</a>&lt;S&gt;(self, subscriber: S) -&gt; <a class="struct" href="https://docs.rs/tracing/0.1.34/tracing/instrument/struct.WithDispatch.html" title="struct tracing::instrument::WithDispatch">WithDispatch</a>&lt;Self&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;S: <a class="trait" href="https://doc.rust-lang.org/1.62.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="struct" href="https://docs.rs/tracing-core/0.1.22/tracing_core/dispatcher/struct.Dispatch.html" title="struct tracing_core::dispatcher::Dispatch">Dispatch</a>&gt;,&nbsp;</span></h4></section></summary><div class='docblock'><p>Attaches the provided <a href="https://docs.rs/tracing-core/0.1.22/tracing_core/subscriber/trait.Subscriber.html"><code>Subscriber</code></a> to this type, returning a
<a href="https://docs.rs/tracing/0.1.34/tracing/instrument/struct.WithDispatch.html" title="WithDispatch"><code>WithDispatch</code></a> wrapper. <a href="https://docs.rs/tracing/0.1.34/tracing/instrument/trait.WithSubscriber.html#method.with_subscriber">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.with_current_subscriber" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://docs.rs/tracing/0.1.34/src/tracing/instrument.rs.html#221">source</a></span><a href="#method.with_current_subscriber" class="anchor"></a><h4 class="code-header">fn <a href="https://docs.rs/tracing/0.1.34/tracing/instrument/trait.WithSubscriber.html#method.with_current_subscriber" class="fnname">with_current_subscriber</a>(self) -&gt; <a class="struct" href="https://docs.rs/tracing/0.1.34/tracing/instrument/struct.WithDispatch.html" title="struct tracing::instrument::WithDispatch">WithDispatch</a>&lt;Self&gt;</h4></section></summary><div class='docblock'><p>Attaches the current <a href="https://docs.rs/tracing/0.1.34/tracing/dispatcher/index.html#setting-the-default-subscriber">default</a> <a href="https://docs.rs/tracing-core/0.1.22/tracing_core/subscriber/trait.Subscriber.html"><code>Subscriber</code></a> to this type, returning a
<a href="https://docs.rs/tracing/0.1.34/tracing/instrument/struct.WithDispatch.html" title="WithDispatch"><code>WithDispatch</code></a> wrapper. <a href="https://docs.rs/tracing/0.1.34/tracing/instrument/trait.WithSubscriber.html#method.with_current_subscriber">Read more</a></p>
</div></details></div></details></div></section></div></main><div id="rustdoc-vars" data-root-path="../../" data-current-crate="rat_rs" data-themes="ayu,dark,light" data-resource-suffix="" data-rustdoc-version="1.62.0 (a8314ef7d 2022-06-27)" ></div>
</body></html>